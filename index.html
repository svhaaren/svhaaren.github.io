<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Komplettes Beispiel</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'Roboto', sans-serif;
    background-color: #000;
    color: #e1e1d8;
    margin: 0;
    padding: 20px;
  }
  .header-text {
    font-family: 'Roboto', sans-serif;
    font-size: 150px;
    text-transform: none;
    text-align: center;
    color: e1e1d8;
    margin: 0;
    line-height: 0.9;
    letter-spacing: +15px;
}
.sub-header-text {
    font-family: 'Roboto', sans-serif;
    font-size: 50px;
    text-transform: none;
    text-align: center;
    color: e1e1d8;
    margin: 0;
    line-height: 0.9;
    letter-spacing: +10px;
}
  .box-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 20px;
  }
  .input-grid-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 20px;
    display: flex;
    justify-content: space-between;
  }
  .transformation-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 20px;
  }
  .controls-container {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    justify-content: center; /* Zentriert die Buttons vertikal */
  }
.left-controls {
  display: flex;
  flex-direction: column;
  gap: 10px; /* Gibt Abstand zwischen den Buttons */
  margin-right: 20px; /* Verringert den Abstand zum Input-Grid auf der rechten Seite */
}

.right-controls {
  display: flex;
  flex-direction: column;
  gap: 10px; /* Gibt Abstand zwischen den Buttons */
  margin-left: 20px; /* Verringert den Abstand zum Input-Grid auf der linken Seite */
}
  .box {
    width: 180px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    background-color: #000;
    padding: 10px;
    margin: 10px;
    border: 2px solid #000;
    position: relative; /* Needed for absolute positioning of overlay */
  }
  .input-grid {
    width: 360px;
    display: grid;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    background-color: #000;
    padding: 20px;
    margin: 20px auto; /* Zentriert das Grid, falls gewünscht */
    border: 2px solid #000;
    position: relative; /* Needed for absolute positioning of overlay */
    grid-template-columns: repeat(3, 120px);
    gap: 5px;
    margin-bottom: 20px;
  }

  .transformation-box {
    width: 180px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    background-color: #000;
    padding: 10px;
    margin: 10px;
    border: 2px solid #000;
    position: relative; /* Needed for absolute positioning of overlay */
  }
  .box:hover .cell, .input-grid:hover .input-cell, .transformation-box:hover .cell {
    filter: none; /* Remove grayscale filter on hover */
  }
  .grid {
    display: grid;
    grid-template-columns: repeat(3, 60px);
    gap: 5px;
    margin-bottom: 20px;
  }
  .cell {
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    font-weight: bold;
    filter: grayscale(100%); /* Apply grayscale filter */
    color: #e1e1d8;
  }
  .input-cell {
    width: 120px;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 36px;
    font-weight: bold;
    background-color: #e1e1d8;
    color: #000;
  }

  .input-cell select {
    width: 100%;
    height: 100%;
    background-color: transparent;
    border: none;
    text-align: center;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    font-size: 36px;
    color: currentColor;
    cursor: pointer;
  }

  .cell-1 { background-color: #e67819; }
  .cell-2 { background-color: #f8cd22; }
  .cell-3 { background-color: #aa6dbe; }
  .cell-4 { background-color: #4ba4bf; }
  .cell-5 { background-color: #b13737; }
  .cell-6 { background-color: #7bac72; }
  .cell-7 { background-color: #734912; }
  .cell-8 { background-color: #d4adba; }
  .cell-9 { background-color: #393939; color: #e1e1d8; }
  button, .search-btn {
    border: 1px solid #e1e1d8;
    background-color: #000;
    color: #e1e1d8;
    padding: 10px 20px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 300;
    letter-spacing: 1px;
    border-radius: 4px;
    transition: background-color 0.3s ease;
    text-transform: uppercase;
    margin-top: 10px;
  }
  button:hover, .search-btn:hover {
    background-color: #e1e1d8;
    color: #000;
  }
  .controls-container {
    flex-direction: column;
  }
  .search-container {
    display: flex;
    gap: 10px;
    align-items: center;
    width: 100%;
  }
  .search-input {
    padding: 10px;
    border: 2px solid #444;
    background-color: #222;
    color: #e1e1d8;
    border-radius: 4px;
    flex-grow: 1;
  }
  
</style>
</head>
<body>
  <header>
    <div class="header-text">MENACE</div>
    <div class="sub-header-text">Companion</div>
  </header>
<div class="search-wrapper">
  <div class="search-container">
    <input type="text" id="searchNumberInput" class="search-input" placeholder="Search Box-Nr....">
    <button class="search-btn" onclick="searchBoxesByNumber()">&#128269;</button>
  </div>

  <div class="search-container">
    <input type="text" id="searchNotationInput" class="search-input" placeholder="Search Notation (;;;;;;;;)">
    <button class="search-btn" onclick="searchBoxesByNotationWithTransformations()">&#128269;</button>
  </div>
</div>

<div class="input-grid-container">
  <div class="left-controls">
    <button onclick="toggleSearchByNumber()" class="search-btn">Search via Box-Nr.</button>
    <button onclick="toggleSearchByNotation()" class="search-btn">Search via Notation</button>
  </div>

  <div id="inputGrid" class="input-grid box"></div>

  <div class="right-controls">
    <button onclick="submitInput()" class="search-btn">Enter Grid Input</button>
    <button onclick="toggleTransformations()" class="search-btn">Hide</button>
  </div>
</div>

<div id="transformationContainer" class="transformation-container"></div>
<div id="boxContainer" class="box-container"></div>














<script>
const boxStates = [
  "(;;;;;;;;)",
  "(;;X;;;;O;;)",
  "(;X;;;;O;;;)",
  "(;;O;;X;;;;)",
  "(;O;X;;;;;;)",
  "(;X;O;;;;;;)",
  "(;;X;O;;;;;)",
  "(;O;;;X;;;;)",
  "(;;O;X;;;;;)",
  "(O;;X;;;;;;)",
  "(;X;;;O;;;;)",
  "(;X;;;;;;O;)",
  "(;;X;;O;;;;)"
];






function toggleSearchByNumber() {
  const searchWrapper = document.querySelector('.search-wrapper .search-container:first-child');
  searchWrapper.style.display = searchWrapper.style.display === 'none' ? 'flex' : 'none';
}

function toggleSearchByNotation() {
  const searchWrapper = document.querySelector('.search-wrapper .search-container:last-child');
  searchWrapper.style.display = searchWrapper.style.display === 'none' ? 'flex' : 'none';
}

document.addEventListener('DOMContentLoaded', () => {
  // Initial verbergen der Sucheingabefelder
  toggleSearchByNumber();
  toggleSearchByNotation();

  createBoxes();
  initInputGrid();
});






function toggleDropdown() {
  var optionsContainer = document.getElementById("optionsContainer");
  if (optionsContainer.style.display === "block") {
    optionsContainer.style.display = "none";
  } else {
    optionsContainer.style.display = "block";
  }
}

function selectOption(event, value) {
  event.stopPropagation(); // Verhindert, dass das toggleDropdown Event erneut aufgerufen wird
  document.getElementById("selectedValue").textContent = value;
  document.getElementById("optionsContainer").style.display = "none";
}

// Optional: Schließt das Dropdown, wenn außerhalb des Dropdowns geklickt wird
window.onclick = function(event) {
  if (!event.target.matches('.custom-select, .custom-select *')) {
    document.getElementById("optionsContainer").style.display = "none";
  }
}





const boxes = boxStates.map((state, index) => ({
  id: index + 1,
  label: `Box ${index + 1}`,
  state: state,
  displayState: state.substring(1, state.length - 1).split(';').map(s => s === "" ? " " : s)
}));

function mapColorClass(index) {
  const colorMapping = [0, 1, 2, 3, 4, 5, 6, 7, 8];
  return `cell-${colorMapping[index] + 1}`;
}

function rotateColorMapping(mapping) {
  return [
    mapping[6], mapping[3], mapping[0],
    mapping[7], mapping[4], mapping[1],
    mapping[8], mapping[5], mapping[2]
  ];
}

function mirrorColorMappingHorizontal(mapping) {
  return [
    mapping[2], mapping[1], mapping[0],
    mapping[5], mapping[4], mapping[3],
    mapping[8], mapping[7], mapping[6]
  ];
}
function toggleTransformations() {
  const transformationContainer = document.getElementById('transformationContainer');
  transformationContainer.style.display = transformationContainer.style.display === 'none' ? 'flex' : 'none';
}
function adjustColorMappingForTransformation(transIndex, colorMapping) {
  switch (transIndex) {
    case 1: // 90° CCW
      return rotateColorMapping(colorMapping);
    case 2: // 180° CCW (zwei 90° Drehungen)
      return rotateColorMapping(rotateColorMapping(colorMapping));
    case 3: // 270° CCW (drei 90° Drehungen)
      return rotateColorMapping(rotateColorMapping(rotateColorMapping(colorMapping)));
    case 4: // Horizontal Mirror
      return mirrorColorMappingHorizontal(colorMapping);
    case 5: // 90° CCW + Mirror
      return mirrorColorMappingHorizontal(rotateColorMapping(colorMapping));
    case 6: // 180° CCW + Mirror (zwei 90° Drehungen + Spiegelung)
      return rotateColorMapping(rotateColorMapping(mirrorColorMappingHorizontal(colorMapping)));
    case 7: // 270° CCW + Mirror (drei 90° Drehungen + Spiegelung)
      return mirrorColorMappingHorizontal(rotateColorMapping(rotateColorMapping(rotateColorMapping(colorMapping))));
    default: // Keine Transformation oder Original
      return colorMapping;
  }
}

function createBoxes(boxesToDisplay = boxes) {
  const container = document.getElementById('boxContainer');
  container.innerHTML = '';
  boxesToDisplay.forEach((box) => {
    const boxElement = document.createElement('div');
    boxElement.classList.add('box');
    const grid = document.createElement('div');
    grid.classList.add('grid');
    box.displayState.forEach((cellState, cellIndex) => {
      const cell = document.createElement('div');
      cell.classList.add('cell', mapColorClass(cellIndex));
      cell.textContent = cellState;
      grid.appendChild(cell);
    });
    const numberElement = document.createElement('div');
    numberElement.classList.add('box-number');
    numberElement.textContent = box.label;
    const rotateButton = document.createElement('button');
    rotateButton.textContent = 'Rotate';
    rotateButton.onclick = () => showTransformations(box.state);
    boxElement.appendChild(grid);
    boxElement.appendChild(numberElement);
    boxElement.appendChild(rotateButton);
    container.appendChild(boxElement);
  });
}

function showTransformations(state) {
  const transformations = generateTransformations(state);
  const transformationContainer = document.getElementById('transformationContainer');
  transformationContainer.innerHTML = '';
  transformationContainer.style.display = 'flex';

  let colorMapping = [0, 1, 2, 3, 4, 5, 6, 7, 8];
  const transformationDescriptions = ["Original", "90° CCW", "180° CCW", "270° CCW", "Horizontal Mirror", "90° CCW + Mirror", "180° CCW + Mirror", "270° CCW + Mirror"];

  transformations.forEach((transformation, transIndex) => {
    const currentColorMapping = adjustColorMappingForTransformation(transIndex, colorMapping);
    const transformationBox = document.createElement('div');
    transformationBox.classList.add('transformation-box');
    const transGrid = document.createElement('div');
    transGrid.classList.add('grid');
    transformation.substring(1, transformation.length - 1).split(';').forEach((cellState, index) => {
      const cell = document.createElement('div');
      cell.classList.add('cell', mapColorClass(currentColorMapping[index]));
      cell.textContent = cellState === "X" || cellState === "O" ? cellState : " ";
      transGrid.appendChild(cell);
    });
    const descriptionElement = document.createElement('div');
    descriptionElement.textContent = transformationDescriptions[transIndex];
    transformationBox.appendChild(transGrid);
    transformationBox.appendChild(descriptionElement);
    transformationContainer.appendChild(transformationBox);
  });
}

function generateTransformations(state) {
  let grid = state.substring(1, state.length - 1).split(';');
  const rotate = (g) => [g[6], g[3], g[0], g[7], g[4], g[1], g[8], g[5], g[2]];
  const mirrorHorizontal = (g) => [g[2], g[1], g[0], g[5], g[4], g[3], g[8], g[7], g[6]];
  let transformations = [grid];
  for (let i = 0; i < 3; i++) transformations.push(rotate(transformations[i]));
  transformations = transformations.concat(transformations.map(transformation => mirrorHorizontal(transformation)));
  return [...new Set(transformations.map(trans => `(${trans.join(';')})`))];
}

function searchBoxesByNumber() {
  const input = document.getElementById('searchNumberInput').value.trim();
  const filteredBoxes = boxes.filter(box => box.label.toLowerCase().includes(input.toLowerCase()));
  createBoxes(filteredBoxes);
}

function searchBoxesByNotationWithTransformations() {
  const input = document.getElementById('searchNotationInput').value.trim().toUpperCase();
  const transformations = generateTransformations(input);
  const filteredBoxes = boxes.filter(box => transformations.includes(box.state.toUpperCase()));
  createBoxes(filteredBoxes);
}

function submitInput() {
  const inputGrid = document.getElementById('inputGrid').getElementsByTagName('select');
  let notation = '(';
  for (let i = 0; i < inputGrid.length; i++) {
    notation += inputGrid[i].value;
    if (i < inputGrid.length - 1) notation += ';';
  }
  notation += ')';
  document.getElementById('searchNotationInput').value = notation;
  searchBoxesByNotationWithTransformations();
  
  // Fügt die Ausblendung der Rotations hinzu
  toggleTransformations();
}

function initInputGrid() {
  const inputGrid = document.getElementById('inputGrid');
  inputGrid.innerHTML = '';
  for (let i = 0; i < 9; i++) {
    const cell = document.createElement('div');
    cell.classList.add('input-cell');
    const select = document.createElement('select');
    select.innerHTML = "<option value=''> </option><option value='X'>X</option><option value='O'>O</option>";
    cell.appendChild(select);
    inputGrid.appendChild(cell);
  }
}

document.addEventListener('DOMContentLoaded', () => {
  createBoxes();
  initInputGrid();
});
</script>
</body>
</html>
